/// otimorm Example
///There are many comments here with hints about the code, but the same comments are never written.
const std = @import("std");
const otimorm = @import("otimorm");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);

    const allocator = gpa.allocator();

    var db = otimorm.Database.init(allocator);
    defer db.deinit();

    //Connect to the database
    try db.connect("postgresql://postgres:postgres@localhost:5432/orm");

    //Before executing a query, you can also specify the query to be executed
    //prepareQuery can be called many times, and everything added there will be executed when .send() is executed.
    try db.prepareQuery("SET search_path TO public;");

    const User = struct {
        //This field is required
        pub const Table = "test_table";

        //Available types depend on pg.zig https://github.com/karlseguin/pg.zig/tree/master?tab=readme-ov-file#getcomptime-t-type-col-usize-t
        test_value: []const u8,
        test_num: ?i32, //The field here can be optional assigning null without making it optional will generate the wrong query
        test_bool: bool,
    };

    {
        std.log.info("Example 1 (insert)", .{});

        //Do not use undefined!
        //The compiler will not be able to find the error and will cause a bug
        var insert = db.insert(User, .{ .test_value = "foo", .test_num = null, .test_bool = false });

        //Errors generated by exec like error.PG are output to the log.
        insert.send() catch |err| {
            //Error details cannot be captured here
            //Because there is no way to access conn.err from here. https://github.com/karlseguin/pg.zig/tree/master?tab=readme-ov-file#important-notice-3---errors

            //example `error: error.PG`
            std.log.err("{any}", .{err});
        };
    }

    {
        std.log.info("Example 2 (select)", .{});

        //In addition to normal types, arrays such as `[]User` can be specified
        var select = db.select([]User);

        //select differs from the others in that the user must manually deinit
        //Because ArenaAllocator is used, if deinit is performed immediately after send is executed, memory is released before the result is used.
        defer select.deinit();

        //The errors that occur here should basically only be related to Allocator
        //If a value other than struct is passed to where, ArgsMustBeStruct error is raised.
        //When null is used in where, it is excluded from the condition of where instead of “only get if null”.
        try select.where(.{ .test_value = "foo", .test_num = null, .test_bool = false });

        const result = select.send() catch null;
        if (result) |models| {
            for (models, 0..) |model, i| {
                std.log.info("{d} result.test_value: {s}", .{ i, model.test_value });
                std.log.info("{d} result.test_num: {d}", .{ i, model.test_num orelse 0 });
                std.log.info("{d} result.test_bool: {any}", .{ i, model.test_bool });
            }
        }
    }

    //TODO: update, delete, deleteAll
}
