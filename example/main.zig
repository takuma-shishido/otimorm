/// otimorm Example
/// There are many comments here with hints about the code, but the same comments are never written.
const std = @import("std");
const otimorm = @import("otimorm");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);

    const allocator = gpa.allocator();

    var db = otimorm.Database.init(allocator);
    defer db.deinit();

    //Connect to the database.
    try db.connect("postgresql://postgres:postgres@localhost:5432/orm");

    //Before executing a query, you can also specify the query to be executed.
    //prepareQuery can be called many times, and everything added there will be executed when .send() is executed.
    try db.prepareQuery("SET search_path TO public;");

    const User = struct {
        //This field is required.
        pub const Table = "test_table";

        //Available types depend on pg.zig https://github.com/karlseguin/pg.zig/tree/master?tab=readme-ov-file#getcomptime-t-type-col-usize-t

        test_value: []const u8,
        test_num: ?i32, //The field here can be optional assigning null without making it optional will generate the wrong query.
        test_bool: bool,
    };

    {
        std.log.info("Example 1 (insert)", .{});

        //Do not use undefined.
        //The compiler will not be able to find the error and will cause a bug.
        var insert = db.insert(User, .{ .test_value = "foo", .test_num = null, .test_bool = false });

        //Errors generated by exec like error.PG are output to the log.
        insert.send() catch |err| {
            //Error details cannot be captured here.
            //Because there is no way to access conn.err from here. https://github.com/karlseguin/pg.zig/tree/master?tab=readme-ov-file#important-notice-3---errors

            //example `error: error.PG`
            std.log.err("{any}", .{err});
        };
    }

    {
        std.log.info("Example 2 (select)", .{});

        var select = db.select(User);

        //select differs from the others in that the user must manually deinit.
        //Because ArenaAllocator is used, if deinit is performed immediately after send is executed, memory is released before the result is used.
        defer select.deinit();

        //The errors that occur here should basically only be related to Allocator.
        //If a value other than struct is passed to where, ArgsMustBeStruct error is raised.
        //When null is used in where, it is excluded from the condition of where instead of “only get if null”.
        try select.where(.{ .test_value = "foo", .test_num = null, .test_bool = false });

        //If multiple values are found, you can specify whether to return the first value found or the last value found.
        //For arrays, this option does nothing
        select.result_selection = .First;

        if (try select.send()) |model| {
            std.log.info("result.test_value: {s}", .{model.test_value});
            std.log.info("result.test_num: {d}", .{model.test_num orelse 0});
            std.log.info("result.test_bool: {any}", .{model.test_bool});
        }
    }

    {
        std.log.info("Example 3 (select, array)", .{});

        //In addition to normal types, arrays such as `[]User` can be specified.
        var select = db.select([]User);
        defer select.deinit();

        try select.where(.{ .test_value = "foo", .test_num = null, .test_bool = false });

        if (try select.send()) |models| {
            for (models, 0..) |model, i| {
                std.log.info("{d} result.test_value: {s}", .{ i, model.test_value });
                std.log.info("{d} result.test_num: {d}", .{ i, model.test_num orelse 0 });
                std.log.info("{d} result.test_bool: {any}", .{ i, model.test_bool });
            }
        }
    }

    {
        std.log.info("Example 4 (select, primary key)", .{});

        const PrimaryKey_User = struct {
            //CREATE TABLE primary_test_table (
            //    id SERIAL PRIMARY KEY,
            //    test_value TEXT
            //);
            pub const Table = "primary_test_table";

            // Attributes such as primary key are not supported.
            // I would like to support them in some way, but I want to avoid making the library difficult to use to implement primary key.
            // https://gorm.io/docs/models.html#Fields-Tags
            // Using field tags like GORM could be one solution, but this is under discussion in Zig and it's unclear when it will be implemented. https://github.com/ziglang/zig/issues/1099
            // The current solution is to set the primary key as optional and use null in the insert to skip the assignment.
            id: ?i32,
            test_value: []const u8,
        };

        var insert = db.insert(PrimaryKey_User, .{ .id = null, .test_value = "foo" });

        insert.send() catch |err| {
            std.log.err("{any}", .{err});
        };

        var select = db.select(PrimaryKey_User);
        defer select.deinit();

        try select.where(.{ .id = null, .test_value = "foo" });

        if (try select.send()) |model| {
            std.log.info("id: {d}", .{model.id.?});
            std.log.info("test_value: {s}", .{model.test_value});
        }
    }

    {
        std.log.info("Example 5 (update)", .{});

        //Note that what is passed here is not a condition like where, but an updated value.
        //Difficult to update only certain values.
        //Can be implemented by making everything optional and using null, but not a good approach.
        var update = db.update(User, .{ .test_value = "hoo", .test_num = null, .test_bool = true });

        try update.where(.{ .test_value = "foo", .test_num = null, .test_bool = false });

        update.send() catch |err| {
            std.log.err("{any}", .{err});
        };
    }

    {
        std.log.info("Example 6 (delete)", .{});

        //delete does the same thing here without the where function
        var delete = db.delete(User, .{ .test_value = "hoo", .test_num = null, .test_bool = true });

        delete.send() catch |err| {
            std.log.err("{any}", .{err});
        };
    }

    {
        std.log.info("Example 7 (deleteAll)", .{});

        //Only Model is needed for deleteAll
        //be careful when using it, as it deletes all the values in Model.Table without conditions.
        var deleteAll = db.deleteAll(User);

        deleteAll.send() catch |err| {
            std.log.err("{any}", .{err});
        };
    }
}
